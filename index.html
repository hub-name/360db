<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8" />
		<title>360</title>
		<link rel="stylesheet" type="text/css" href="css/reset.css" />
		<link rel="stylesheet" type="text/css" href="css/css.css" />
	</head>

	<body>
		<div class="g-main main clearfix">
			<div class="g-left m-left">
				<div class="hd-logo">
					<img src="img/logo.png" />
				</div>
				<div class="m-lbox mt10 bt">
					<div class="lb-head">
						<div class="lbh-msg-name">
							网站名称
						</div>
						<div class="lbh-msg-url">
							http://www.360.cn/
						</div>
					</div>
					<div class="lb-center">
						<div class="lbc-data">
							<h5>攻击数</h5>
							<div class="anum">106</div>
							<div class="aqs"><img src="img/qss.png" /></div>
							<div class="abfb">20%</div>
						</div>
						<div class="lbc-chart" id="chart1">
						</div>
					</div>
				</div>
				<div class="m-lbox">
					<div class="lb-head">
						<div class="lbh-msg-name">
							网站名称
						</div>
						<div class="lbh-msg-url">
							http://www.360.cn/
						</div>
					</div>
					<div class="lb-center">
						<div class="lbc-data">
							<h5>攻击数</h5>
							<div class="anum">106</div>
							<div class="aqs"><img src="img/qss.png" /></div>
							<div class="abfb">20%</div>
						</div>
						<div class="lbc-chart" id="chart2">
						</div>
					</div>
				</div>
				<div class="m-lbox">
					<div class="lb-head">
						<div class="lbh-msg-name">
							网站名称
						</div>
						<div class="lbh-msg-url">
							http://www.360.cn/
						</div>
					</div>
					<div class="lb-center">
						<div class="lbc-data">
							<h5>攻击数</h5>
							<div class="anum">106</div>
							<div class="aqs"><img src="img/qss.png" /></div>
							<div class="abfb">20%</div>
						</div>
						<div class="lbc-chart" id="chart3">
						</div>
					</div>
				</div>
				<div class="m-lbox">
					<div class="lb-head">
						<div class="lbh-msg-name">
							网站名称
						</div>
						<div class="lbh-msg-url">
							http://www.360.cn/
						</div>
					</div>
					<div class="lb-center">
						<div class="lbc-data">
							<h5>攻击数</h5>
							<div class="anum">106</div>
							<div class="aqs"><img src="img/qss.png" /></div>
							<div class="abfb">20%</div>
						</div>
						<div class="lbc-chart" id="chart4">
						</div>
					</div>
				</div>
			</div>
			<div class="g-center">
				<div class="g-centerc m-center">
					<div class="hd-title">
					</div>
					<div class="gc-alrn">
						<ul>
							<li class="gca-all" id="gca-all">攻击总数：0</li>
							<li class="gca-high" id="gca-high">高危：0</li>
							<li class="gca-middle" id="gca-middle">中危：0</li>
							<li class="gca-low" id="gca-low">低危：0</li>
						</ul>
					</div>
					<div class="g-earth">
						<div id="mapEarth"></div>
					</div>
				</div>

			</div>
			<div class="g-right m-right">
				<div class="hd-data">
					<span>2017.3.6   12:00~2017.3.7   12:00</span>
				</div>
				<div class="m-rbox mt15 bt">
					<h3>高危网页路径</h3>
					<ul class="m-web">
						<li><span class="mw-url">URL</span><span class="mw-num">攻击次数</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
						<li><span class="mw-url">https://www.baidu.com/</span><span class="mw-num">3</span></li>
					</ul>
				</div>
				<div class="m-rbox">
					<h3>滚动播放攻击列表</h3>
					<ul class="m-atkList">
						<li>
							<span class="mal-time">攻击时间</span>
							<span class="mal-aim">攻击目标</span>
							<span class="mal-type">攻击类型</span>
							<span class="mal-source">攻击来源</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
						<li>
							<span class="mal-time">10:10</span>
							<span class="mal-aim">个人信息</span>
							<span class="mal-type">木马</span>
							<span class="mal-source">美国</span>
						</li>
					</ul>
				</div>
			</div>
		</div>
		<script src="js/jquery.js" type="text/javascript" charset="utf-8"></script>
		<script src="js/echarts.min.js" type="text/javascript" charset="utf-8"></script>
		<script src="js/chart-option.js" type="text/javascript" charset="utf-8"></script>
		<script src="js/listload.js" type="text/javascript" charset="utf-8"></script>
		
		<script src="js/datetime.js" type="text/javascript" charset="utf-8"></script>
		<script src="reath/js/three.js"></script>
		<script src="reath/js/loaders/MTLLoader.js"></script>
		<script src="reath/js/loaders/OBJLoader.js"></script>
		<script src="reath/js/controls/OrbitControls.js"></script>
		<script src="reath/js/Tween.js"></script>
		<script src="reath/js/jquery-3.1.1.min.js"></script>
		<script src="reath/js/GPUParticleSystem.js"></script>
		<script id="vertexShader" type="x-shader/x-vertex">
			uniform vec3 viewVector; uniform float c; uniform float p; varying float intensity; void main() { vec3 vNormal = normalize( normalMatrix * normal ); vec3 vView = normalize( normalMatrix * viewVector ); intensity = pow( c - dot(vNormal, vView), p ); gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }
		</script>

		<script id="fragmentShader" type="x-shader/x-vertex">
			uniform vec3 glowColor; varying float intensity; void main() { vec3 glow = glowColor * intensity; gl_FragColor = vec4( glow, 1 ); }
		</script>

		<script>
			//全局参数
			var camMaxDistance = 600;

			var radius = 100;
			var cubeScaleFactor = 0.33;
			var cloudCubeYellowAlarmValue = 50; //百分比
			var cloudCubeRedAlarmValue = 70; //百分比
			var cameraDefalutPos = new THREE.Vector3(362, 326, -113);
			//var cameraDefalutPos = new THREE.Vector3(353, 215, -113);

			var circleSegmentCount = 64;
			var circleMiddelLength = 5;
			var circleTurboFactor = 8;
			var lineWidth = 2;
			var circleScaleFactor = 0.5;

			var lineMatGreen = new THREE.LineBasicMaterial({
				color: 0x00FF00,
				linewidth: lineWidth
			});
			var lineMatRed = new THREE.LineBasicMaterial({
				color: 0xff0000,
				linewidth: lineWidth
			});

			var container, scene, camera, renderer;
			var controls;
			var isResetCamPos = false;
			var dirMainLight;

			var earthObj;
			var cityLocationObjs = [];
			var citySelectorObjs = [];
			var cityNameObjs = [];
			var cloudCubes = [];
			var selectorMatAlarm;
			var selectorMatOrigin;
			var allCircleLines = [];
			var allCircleLinesDic = [];
			var earthFallOff;
			var cityLinePlaneObjs = [];
			var outGeo;

			var backlightObj = null;
			var selectorIns = null;
			var locationIns = null;

			var zeroVec3 = new THREE.Vector3(0, 0, 0);

			//云资源变量测试参数
			var cloudResourceTestArgs = {
				"beijing": 52,
				"liaoyuan": 16,
				"kunshan": 75,
				"meishan": 9,
				"shenzhen": 4,
				"wuhan": 8,
				"wuxi": 7,
				"xiangyang": 21,
				"xinxian": 6,
				"yantai": 7,
				"SanFrancisco": 55
			}

			//辽源、北京、烟台、襄阳、新县、武汉、无锡、昆山、眉山、深圳
			var cityNameTextureWidth = 128;
			var cityNameTextureHeight = 64;

			var mousePos = new THREE.Vector2();
			var allDataFlowObjs = [];
			var isMouseMoveFuncRun = false;

			function init() {

				$("#mapEarth").mousemove(function(evt) {
					//translate mousepos to (-1, 1)，(0, 0) position is middle of the Element。
					mousePos.x = (evt.offsetX / 1600) * 2 - 1;
					mousePos.y = -(evt.offsetY / 900) * 2 + 1;
				});

				container = document.getElementById("mapEarth");
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 2000);
				renderer = new THREE.WebGLRenderer({
					alpha: true,
					antialias: true
				});
				//renderer.domElement.ondblclick = onDoubleClick;
				renderer.domElement.onmousemove = onRayMouseMove;
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(container.clientWidth, container.clientHeight);
				container.appendChild(renderer.domElement);

				//var axies = new THREE.AxisHelper(200);
				//scene.add(axies);

				camera.position.z = 500;

				controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.enableZoom = true;
				//controls.minDistance = 180;
				controls.minDistance = 0;
				controls.maxDistance = camMaxDistance;
				controls.minPolarAngle = 0.2;
				controls.maxPolarAngle = Math.PI - 0.2;

				//add Light
				var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
				scene.add(ambientLight);

				dirMainLight = new THREE.DirectionalLight(0xfffde1, 0.7);
				dirMainLight.position.set(120, 120, 100);
				//dirMainLight.lookAt(zeroVec3);
				scene.add(dirMainLight);

				//var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
				//scene.add(light);

				////add Light
				//var ambientLight = new THREE.DirectionalLight(0xff0000, 0.8);
				//scene.add(ambientLight);

				loadScene();

				render();
			}

			function loadScene() {
				var mtlLoader = new THREE.MTLLoader();
				mtlLoader.setPath("reath/models/");
				mtlLoader.load("earth.mtl", function(materials) {
					materials.preload();

					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials(materials);

					objLoader.setPath("reath/models/");
					objLoader.load("earth.obj", function(objects) {
						scene.add(objects);

						objects.name = "EarthObjs";

						objects.traverse(function(child) {
							if(child instanceof THREE.Mesh) {

								if(child.name == "Earth") {
									earthObj = child;
									//child.visible = false;
									child.material = new THREE.MeshLambertMaterial({
										color: 0x01000a,
										shading: THREE.SmoothShading
									});
								}

								if(child.name.split('_')[0] == "EarthShell") {
									child.scale.set(1.01, 1.01, 1.01);
									child.rotateY(Math.PI * 0.573);
									//child.material = new THREE.MeshLambertMaterial({ color: 0x33a5e4, shading: THREE.SmoothShading });
									child.material = new THREE.MeshLambertMaterial({
										color: 0xffffff,
										map: child.material.map,
										shading: THREE.SmoothShading,
										transparent: true,
										opacity: 0.7
									});
								}

								if(child.name == "Earth_Wireframe") {
									child.scale.set(1.004, 1.004, 1.004);
									//child.material = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
									//child.material = new THREE.MeshLambertMaterial({ map: child.material.map, color: 0x8f7ad9, blending: THREE.NormalBlending });

									//child.material = new THREE.MeshPhongMaterial({
									//    color: 0xaaaaaa, specular: 0xffffff, shininess: 20,
									//    side: THREE.DoubleSide, vertexColors: THREE.VertexColors
									//});

									child.material = new THREE.MeshPhongMaterial({
										map: child.material.map,
										//color: 0xff00e2,
										specular: 0xff00e2,
										shininess: 30,
										//side: THREE.DoubleSide,
										transparent: true,
										opacity: 0.3,
										blending: THREE.AdditiveBlending,
										emissive: 0x000000
									});

									//child.visible = false;
								}

								if(child.name == "Earth_WireframePoint") {
									child.scale.set(1.005, 1.005, 1.005);

									child.material = new THREE.MeshPhongMaterial({
										map: child.material.map,
										//color: 0xff00e2,
										//specular: 0xff00e2,
										//shininess: 30,
										//side: THREE.DoubleSide,
										transparent: true,
										opacity: 0.9,
										blending: THREE.AdditiveBlending,
										//emissive: 0x000000
									});
								}

								if(child.name == "OutGeo") {
									child.material = new THREE.MeshBasicMaterial({
										color: 0x92d6f2,
										wireframe: true,
										transparent: true,
										opacity: 0.06
									});
									outGeo = child;
								}

								if(child.name == "EarthBackLight") {
									var matNew = new THREE.MeshBasicMaterial({
										map: child.material.map,
										transparent: true,
										opacity: 1
									});
									child.material = matNew;
									backlightObj = child;
									//child.visible = false;
								}

								if(child.name == "Selector") {
									//var matNew = new THREE.MeshBasicMaterial({ map: child.material.map, transparent: true, opacity: 1, side: THREE.DoubleSide, depthWrite: false, depthTest: false });
									var matNew = new THREE.MeshBasicMaterial({
										map: child.material.map,
										side: THREE.DoubleSide,
										transparent: true
									});
									child.material = matNew;
									selectorIns = child;

									selectorMatAlarm = new THREE.MeshBasicMaterial({
										map: child.material.map,
										side: THREE.DoubleSide,
										transparent: true
									});
									selectorMatOrigin = matNew;
									//child.visible = false;
								}

								if(child.name == "Location") {
									locationIns = child;

									var matLocation = new THREE.MeshPhongMaterial({
										color: 0xffff00,
										emissive: 0xffff00,
										side: THREE.DoubleSide
									});
									child.material = matLocation;
									//child.visible = false;
								}

								if(child.name == "DataFlow") {
									//child.visible = false;
								}
							}
						})

						camera.position.set(cameraDefalutPos.x, cameraDefalutPos.y, cameraDefalutPos.z);
						camera.lookAt(zeroVec3);

						//createCitys();

						createAirEffect();
					})
				})
			}

			function createAirEffect() {

				var fallOffMaterial = new THREE.ShaderMaterial({
					uniforms: {
						"c": {
							type: "f",
							value: 0.9
						},
						"p": {
							type: "f",
							value: 1.6
						},
						glowColor: {
							type: "c",
							value: new THREE.Color(0x89b3ff)
						},
						viewVector: {
							type: "v3",
							value: camera.position
						}
					},
					vertexShader: document.getElementById('vertexShader').textContent,
					fragmentShader: document.getElementById('fragmentShader').textContent,
					side: THREE.FrontSide,
					blending: THREE.AdditiveBlending,
					transparent: true
				});

				var sphereGeom = new THREE.SphereGeometry(100, 40, 40);
				earthFallOff = new THREE.Mesh(sphereGeom.clone(), fallOffMaterial.clone());
				earthFallOff.position = earthObj.position;
				earthFallOff.scale.multiplyScalar(1.0055);
				scene.add(earthFallOff);
			}

			function createCitys() {

				//for (var i = -9; i <= 9; i++) {
				//    creatCitys(i * 10, 116.4);
				//}

				creatCitys("辽源", "liaoyuan", 42.894, 125.150);
				creatCitys("北京", "beijing", 39.911, 116.4);
				creatCitys("烟台", "yantai", 37.469, 121.454);
				creatCitys("襄阳", "xiangyang", 32.014, 112.129);
				creatCitys("新县", "xinxian", 31.6497, 114.885);
				creatCitys("武汉", "wuhan", 30.598, 114.3118);
				creatCitys("无锡", "wuxi", 31.4967, 120.3189);
				creatCitys("昆山", "kunshan", 31.39, 120.988);
				creatCitys("眉山", "meishan", 30.081, 103.855);
				creatCitys("深圳", "shenzhen", 22.548, 114.066);
				creatCitys("旧金山", "SanFrancisco", 37.46, -122.26);
				creatCitys("海口", "haikou", 20, 110);
			}

			//根据经纬度创建城市的Location、Selector、城市名称。（latitude 纬度、longitude 经度）
			function creatCitys(cityChineseName, cityEnglishName, latitude, longitude) {
				var x = Math.sin(longitude * Math.PI / 180) * Math.cos(latitude * Math.PI / 180);
				var z = Math.cos(longitude * Math.PI / 180) * Math.cos(latitude * Math.PI / 180);

				var y = Math.sin(latitude * Math.PI / 180);

				//console.log(x, y, z);
				if(longitude > 0 && longitude < 180) {
					x = Math.abs(x);
				}
				if(longitude >= -180 && longitude <= 0) {
					x = -Math.abs(x);
				}

				if(longitude > -90 && longitude < 90) {
					z = Math.abs(z);
				}
				if(longitude > -180 && longitude <= -90 || longitude >= 90 && longitude <= 180) {
					z = -Math.abs(z);
				}
				//console.log(x, y, z);

				//生成当前城市的Location
				var cityLoction = locationIns.clone();
				cityLoction.position.set(x * radius, y * radius, z * radius);
				cityLoction.lookAt(new THREE.Vector3(0, 0, 0));
				cityLoction.rotateX(-Math.PI / 2);
				cityLoction.translateY(0.4);
				scene.add(cityLoction);
				cityLoction.visible = true;
				cityLoction.name = "Location_" + cityEnglishName;
				cityLocationObjs.push(cityLoction);

				//生成当前城市的Selector
				var citySelector = selectorIns.clone();
				citySelector.position.set(x * radius, y * radius, z * radius);
				citySelector.lookAt(new THREE.Vector3(0, 0, 0));
				citySelector.rotateX(-Math.PI / 2);
				citySelector.translateY(1.4);
				scene.add(citySelector);
				citySelector.visible = true;
				citySelector.name = "Selector_" + cityEnglishName;
				citySelectorObjs.push(citySelector);

				//创建当前城市的名称
				var namePlaneObj = createCanvas(cityChineseName, cityEnglishName, x * radius, y * radius, z * radius);
				cityNameObjs.push(namePlaneObj);
			}

			//创建当前城市的名称面片Mesh，并贴图
			function createCanvas(cityChineseName, cityEnglishName, x, y, z) {
				var canvas = document.createElement('canvas');
				context = canvas.getContext('2d');

				canvas.width = cityNameTextureWidth;
				canvas.height = cityNameTextureHeight;

				context.font = '25pt 微软雅黑';
				context.fillStyle = 'red';
				context.textAlign = "center";
				context.textBaseline = "middle";
				context.fillText(cityChineseName, canvas.width / 2, canvas.height / 2);

				var canvasTexture = new THREE.CanvasTexture(canvas);
				var material = new THREE.MeshBasicMaterial({
					map: canvasTexture,
					transparent: true,
					depthWrite: false
				});
				var plane = new THREE.PlaneGeometry(8, 4);
				var namePlaneObj = new THREE.Mesh(plane, material);
				namePlaneObj.position.set(x, y, z);
				namePlaneObj.lookAt(new THREE.Vector3(0, 0, 0));
				namePlaneObj.rotateY(Math.PI + 0.05);
				namePlaneObj.translateY(-3);
				namePlaneObj.translateZ(1.5);
				namePlaneObj.name = "CityName_" + cityEnglishName;
				scene.add(namePlaneObj);

				return namePlaneObj;
			}

			//生成云资源柱 0-50% 绿色，50%-70%黄色，大于70%红色
			function generateCubeColumn(cloudResource) {

				//showAllNameMesh();
				//hideAllLinkLine();
				//stopAllSecurityIncidents();

				destoryCloudCube();

				for(var i = 0; i < cloudCityLocationObjs.length; i++) {

					var lacationObj = cloudCityLocationObjs[i];

					var cubeOriginlen = cloudResource[lacationObj.name.split("_")[1]];

					var boxGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
					var matBox = new THREE.MeshBasicMaterial({
						color: 0x00ff00
					});
					var cloudCubeMesh = new THREE.Mesh(boxGeo, matBox);

					cloudCubeMesh.name = "cloudCube_" + lacationObj.name.split("_")[1];
					cloudCubes.push(cloudCubeMesh);

					var matCube = new THREE.MeshBasicMaterial({
						transparent: true,
						opacity: 0.8
					});

					//根据等级调云资源柱颜色
					var rColor = 0,
						gColor = 0;

					if(cubeOriginlen < cloudCubeYellowAlarmValue) {
						rColor = 0;
						gColor = 1;
					} else if(cubeOriginlen >= cloudCubeYellowAlarmValue && cubeOriginlen < cloudCubeRedAlarmValue) {
						rColor = 1;
						gColor = 1;
					} else if(cubeOriginlen >= cloudCubeRedAlarmValue) {
						rColor = 1;
						gColor = 0;
					}

					matCube.color.r = rColor;
					matCube.color.g = gColor;
					matCube.color.b = 0;

					cloudCubeMesh.material = matCube;

					scene.add(cloudCubeMesh);

					var widthHalf = renderer.domElement.clientWidth / 2;
					var heightHalf = renderer.domElement.clientHeight / 2;

					var locationPos = lacationObj.position.clone();

					//NEW WAY
					cloudCubeMesh.position.set(lacationObj.position.x, lacationObj.position.y, lacationObj.position.z);
					cloudCubeMesh.lookAt(new THREE.Vector3(0, 0, 0));
					cloudCubeMesh.rotateX(-Math.PI / 2);

					//模拟轴心调到底部效果
					cloudCubeMesh.geometry.translate(0, 1 / 2, 0);
					cloudCubeMesh.scale.set(1, cubeOriginlen * cubeScaleFactor, 1);
				}
			}

			//清除云资源柱
			function destoryCloudCube() {
				for(var i = 0; i < cloudCubes.length; i++) {
					cloudCubes[i].material.dispose();
					cloudCubes[i].geometry.dispose();
					scene.remove(cloudCubes[i]);
				}

				cloudCubes = [];
			}

			var allTweens = new Array();
			var allTweensObjs = new Array();
			var securityTweenSpeed = 1000;
			var securityLevel = 3;

			//根据攻击报警等级缩放圆圈
			function setSecurityIncidentsLevel(nodeName, level) { //1:level1, 2：level2, 3：level3

				//destoryCloudCube();
				//hideAllLinkLine();
				//showAllSelectorAndNameMesh();

				var obj = scene.getObjectByName("Selector_" + nodeName);

				obj.material = selectorMatAlarm;

				obj.scale.set(0.8, 0.8, 0.8);
				allTweensObjs.push(obj);

				//放大Tween动画
				var tweenScale = new TWEEN.Tween(obj.scale)
					.to({
						x: level / 2 + 1,
						y: level / 2 + 1,
						z: level / 2 + 1
					}, securityTweenSpeed)
					.repeat(Infinity)
					//.delay(1000)
					//.onUpdate(function () {})
					//.easing(TWEEN.Easing.Elastic.Out)
					.easing(TWEEN.Easing.Cubic.Out)
					.start();

				var tweenColor = new TWEEN.Tween(obj.material.color)
					.to({
						r: 1,
						g: 1 - level / securityLevel,
						b: 0
					}, securityTweenSpeed)
					.repeat(Infinity)
					.easing(TWEEN.Easing.Cubic.Out)
					.start();

				allTweens.push(tweenScale);
				allTweens.push(tweenColor);
			}

			//停止攻击缩放圆圈
			function stopAllSecurityIncidents() {

				//destoryCloudCube();
				//hideAllLinkLine();
				//showAllSelectorAndNameMesh();

				for(var i = 0; i < allTweens.length; i++) {
					allTweens[i].stop();
				}

				for(var i = 0; i < allTweensObjs.length; i++) {
					allTweensObjs[i].scale.set(1, 1, 1);
					allTweensObjs[i].material = selectorMatOrigin;
				}
			}

			//显示单个城市节点，其它隐藏
			function showSingleCity(cityEnglishName) {

				showAllCity();

				for(var i = 0; i < cityLocationObjs.length; i++) {
					if(cityLocationObjs[i].name.split('_')[1] != cityEnglishName) {
						cityLocationObjs[i].visible = false;
					}
				}

				for(var i = 0; i < citySelectorObjs.length; i++) {
					if(citySelectorObjs[i].name.split('_')[1] != cityEnglishName) {
						citySelectorObjs[i].visible = false;
					}
				}

				for(var i = 0; i < cityNameObjs.length; i++) {
					if(cityNameObjs[i].name.split('_')[1] != cityEnglishName) {
						cityNameObjs[i].visible = false;
					}
				}
			}

			//显示所有城市节点
			function showAllCity() {
				for(var i = 0; i < cityLocationObjs.length; i++) {
					cityLocationObjs[i].visible = true;
				}

				for(var i = 0; i < citySelectorObjs.length; i++) {
					citySelectorObjs[i].visible = true;
				}

				for(var i = 0; i < cityNameObjs.length; i++) {
					cityNameObjs[i].visible = true;
				}

				rotateToCity("beijing");
			}

			function CreateCityLine(cityName1, cityName2) {
				var cityPos1 = scene.getObjectByName("Location_" + cityName1).position;
				var cityPos2 = scene.getObjectByName("Location_" + cityName2).position;

				var circleTwoCityMiddlePos = new THREE.Vector3(cityPos1.x / 2 + cityPos2.x / 2, cityPos1.y / 2 + cityPos2.y / 2, cityPos1.z / 2 + cityPos2.z / 2);

				//创建圆线圈

				//圆圈半径
				var radianCircle = cityPos1.distanceTo(cityPos2) / 2;

				var lineGeometry = new THREE.Geometry();

				for(var i = 0; i <= circleSegmentCount; i++) {
					var theta = (i / circleSegmentCount) * Math.PI * 2;

					//if (i >= circleSegmentCount / 2)
					{
						//圆形
						//var valueZ = Math.sin(theta) * radianCircle;

						//跑道环形
						if(i == 0 || i == circleSegmentCount / 2 || i == circleSegmentCount) {
							var valueZ = Math.sin(theta) * radianCircle;
						} else if(i < circleSegmentCount / 2) {
							var valueZ = Math.sin(theta) * radianCircle + circleMiddelLength;
						} else if(i > circleSegmentCount / 2) {
							var valueZ = Math.sin(theta) * radianCircle - circleMiddelLength;
						}

						var valueY = 0;
						if(valueZ > 0) {
							valueY = Math.sin(theta * 2) * radianCircle / circleTurboFactor;
						} else if(valueZ < 0) {
							valueY = -Math.sin(theta * 2) * radianCircle / circleTurboFactor;
						}

						lineGeometry.vertices.push(
							new THREE.Vector3(
								Math.cos(theta) * radianCircle,
								valueY,
								valueZ
							));
					}
				}

				var circleObj = new THREE.Line(lineGeometry, lineMatGreen);
				circleObj.name = cityName1 + "_" + cityName2;
				allCircleLines.push(circleObj);
				allCircleLinesDic[cityName1 + "_" + cityName2] = circleObj;
				circleObj.position.set(circleTwoCityMiddlePos.x, circleTwoCityMiddlePos.y, circleTwoCityMiddlePos.z);
				scene.add(circleObj);

				var circleOriginZeroPoint = circleObj.geometry.vertices[0].clone();
				var circleOriginQuarterPoint = circleObj.geometry.vertices[circleSegmentCount / 4].clone();
				var circleOriginHalfPoint = circleObj.geometry.vertices[circleSegmentCount / 2].clone();

				circleObj.lookAt(zeroVec3);

				//计算圆圈上0、1/2处的点在世界空间的坐标。
				var circleZeroPoint1 = circleOriginZeroPoint.clone();
				var circleHalfPoint1 = circleOriginHalfPoint.clone();

				circleObj.updateMatrixWorld();
				circleZeroPoint1.applyMatrix4(circleObj.matrixWorld);
				circleHalfPoint1.applyMatrix4(circleObj.matrixWorld);

				//圆圈的起点到中间点的向量，起点坐标 减 中间点坐标，向量从起点指向中间点。
				var vectorCircleZeroToHalf = new THREE.Vector3(circleZeroPoint1.x - circleHalfPoint1.x, circleZeroPoint1.y - circleHalfPoint1.y, circleZeroPoint1.z - circleHalfPoint1.z);
				//city2到city1的向量，城市2坐标 减 城市1坐标，向量从城市1指向城市2
				var vectorTwoCity = new THREE.Vector3(cityPos2.x - cityPos1.x, cityPos2.y - cityPos1.y, cityPos2.z - cityPos1.z);

				var lineCityLineCircleThetha = Math.acos(vectorTwoCity.dot(vectorCircleZeroToHalf) / (vectorTwoCity.length() * vectorCircleZeroToHalf.length()));

				//console.log(cityName1 + " and " + cityName2 + ": " + lineCityLineCircleThetha * (180 / Math.PI));

				if(cityPos1.y > cityPos2.y) {
					circleObj.rotateZ(-lineCityLineCircleThetha);
				} else if(cityPos1.y < cityPos2.y) {
					circleObj.rotateZ(lineCityLineCircleThetha);
				}
				circleObj.scale.set(1, 1, circleScaleFactor);
			}

			function calCamToCityAngle(destCity) {

				var destCityPosition = new THREE.Vector3(0 - destCity.position.x, 0 - destCity.position.y, 0 - destCity.position.z);
				var cameraPosition = new THREE.Vector3(0 - camera.position.x, 0 - camera.position.y, 0 - camera.position.z);
				var angleCamToDst;

				if(destCityPosition.length() != 0 && cameraPosition.length() != 0) {
					angleCamToDst = Math.acos(destCityPosition.dot(cameraPosition) / (destCityPosition.length() * cameraPosition.length()));
				}
				return angleCamToDst;
			}

			function calCamToCityRotAxis(destCity) {
				var destCityPosition = new THREE.Vector3(0 - destCity.position.x, 0 - destCity.position.y, 0 - destCity.position.z);
				var cameraPosition = new THREE.Vector3(0 - camera.position.x, 0 - camera.position.y, 0 - camera.position.z);

				var rotAxis = cameraPosition.cross(destCityPosition);
				return rotAxis;
			}

			function rotateAroundWorldAxis(object, axis, angle) {
				var rotationMatrix = new THREE.Matrix4();
				rotationMatrix.makeRotationAxis(axis.normalize(), angle);
				var currentPos = new THREE.Vector4(object.position.x, object.position.y, object.position.z, 1);
				var newPos = currentPos.applyMatrix4(rotationMatrix);
				object.position.set(newPos.x, newPos.y, newPos.z);
			}

			//定位到城市
			function rotateToCity(cityName) {

				var destCity = scene.getObjectByName("Location_" + cityName);

				if(destCity == null) {
					console.log("目标城市不存在，请检查！");
					return
				}

				var rotAxis = calCamToCityRotAxis(destCity);
				var rotAngleOffset = 0;

				var coords = {
					rotAngle: 0
				};
				var tweenRot = new TWEEN.Tween(coords)
					.to({
						rotAngle: calCamToCityAngle(destCity)
					}, 2000)
					.onUpdate(function() {

						rotateAroundWorldAxis(camera, rotAxis, this.rotAngle - rotAngleOffset);
						rotAngleOffset = this.rotAngle;

						camera.lookAt(zeroVec3);
					})
					//.easing(TWEEN.Easing.Cubic.Out)
					.easing(TWEEN.Easing.Sinusoidal.InOut)
					.start();

				allTweens.push(tweenRot);
			}

			function createCityLinePanelTest() {

				//创建顶点
				var v1 = new THREE.Vector3(0, 0, 0);
				var v2 = new THREE.Vector3(0, 0, 10);
				var v3 = new THREE.Vector3(10, 0, 0);
				var v4 = new THREE.Vector3(10, 0, 10);
				var v5 = new THREE.Vector3(20, 0, 0);
				var v6 = new THREE.Vector3(20, 0, 10);
				var v7 = new THREE.Vector3(30, 0, 0);
				var v8 = new THREE.Vector3(30, 0, 10);
				var v9 = new THREE.Vector3(40, 0, 0);
				var v10 = new THREE.Vector3(40, 0, 10);

				var geom = new THREE.Geometry();

				geom.vertices.push(v1);
				geom.vertices.push(v2);
				geom.vertices.push(v3);
				geom.vertices.push(v4);
				geom.vertices.push(v5);
				geom.vertices.push(v6);
				geom.vertices.push(v7);
				geom.vertices.push(v8);
				geom.vertices.push(v9);
				geom.vertices.push(v10);

				//逆时针顺序
				geom.faces.push(new THREE.Face3(0, 3, 2));
				geom.faces.push(new THREE.Face3(3, 0, 1));
				geom.faces.push(new THREE.Face3(2, 5, 4));
				geom.faces.push(new THREE.Face3(5, 2, 3));
				geom.faces.push(new THREE.Face3(4, 7, 6));
				geom.faces.push(new THREE.Face3(7, 4, 5));
				geom.faces.push(new THREE.Face3(6, 9, 8));
				geom.faces.push(new THREE.Face3(9, 6, 7));

				var faces = geom.faces;

				var facesLength = faces.length;

				var percentNumber = 1 / facesLength;
				var forCount = 1;

				for(var i = 0; i < facesLength; i++) {

					if(i % 2 == 0) {
						geom.faceVertexUvs[0].push([
							new THREE.Vector2((forCount - 1) * (2 * percentNumber), 1),
							new THREE.Vector2(forCount * (2 * percentNumber), 0),
							new THREE.Vector2(forCount * (2 * percentNumber), 1)
						])
					} else {
						geom.faceVertexUvs[0].push([
							new THREE.Vector2(forCount * (2 * percentNumber), 0),
							new THREE.Vector2((forCount - 1) * (2 * percentNumber), 1),
							new THREE.Vector2((forCount - 1) * (2 * percentNumber), 0),
						])

						forCount++;
					}
				}

				//更新geometry信息。
				geom.computeBoundingBox();
				geom.computeFaceNormals();
				geom.computeVertexNormals();
				geom.verticesNeedUpdate = true;
				geom.elementsNeedUpdate = true;
				geom.uvsNeedUpdate = true;
				geom.normalsNeedUpdate = true;
				geom.colorsNeedUpdate = true;
				geom.tangentsNeedUpdate = true;

				var movingLineTexture = new THREE.ImageUtils.loadTexture('reath/models/movingLine.png');
				movingLineTexture.wrapS = movingLineTexture.wrapT = THREE.RepeatWrapping;

				//var movingLineMat = new THREE.MeshBasicMaterial({ map: movingLineTexture, transparent: true, opacity: 1, side: THREE.DoubleSide });
				var movingLineMat = new THREE.MeshBasicMaterial({
					map: movingLineTexture,
					transparent: true,
					opacity: 1,
					blending: THREE.AdditiveBlending
				});

				var wireMaterial = new THREE.MeshBasicMaterial({
					color: 0xffffff,
					wireframe: true
				})

				var cityLinePlaneObj = new THREE.Mesh(geom, movingLineMat);
				cityLinePlaneObjs.push(cityLinePlaneObj);

				scene.add(cityLinePlaneObj);
			}

			function createCityLinePlane(cityStartName, cityEndName, attackLevel) {

				var cityStart = scene.getObjectByName("Location_" + cityStartName);
				var cityEnd = scene.getObjectByName("Location_" + cityEndName);

				var distanceTwoCity = cityStart.position.distanceTo(cityEnd.position);

				//是否曲线显示
				var isSinLine = false;

				//连线Z轴的缩放倍数（连线像两边摆动的幅度倍数），根据两个城市直线距离的大小来做适应缩放。
				var zMultiply = distanceTwoCity / 20;

				//面片宽度倍数
				var widthMultipy = 2;

				//连线面片数倍数（有些城市太近，默认生成的面片数太少，曲线显示时菱角太分明，效果不好）
				var quadrangleSegmentNumberMultiply = 2;

				//连线Y轴的缩放
				var yMultiply = (distanceTwoCity / (radius * 2)) * 1.2;

				//俩城市直线距离的一半，半圆的半径长度。
				var segmentSphereRadius = distanceTwoCity / 2;

				//自动生成面片的段数。
				var quadrangleSegmentNumber = Math.floor(distanceTwoCity) * quadrangleSegmentNumberMultiply;

				//面片的长度
				var segmentLength = distanceTwoCity / quadrangleSegmentNumber;

				//面片的宽度
				var segmentWidth = segmentLength * widthMultipy;

				//半圆面片线每个面片的间距
				var angleStep = Math.PI / quadrangleSegmentNumber;

				var geom = new THREE.Geometry();

				////创建顶点
				//var v1 = new THREE.Vector3(0, 0, 0);
				//var v2 = new THREE.Vector3(0, 0, segmentWidth);
				//var v3 = new THREE.Vector3(segmentSphereRadius - segmentSphereRadius * Math.cos(angleStep), Math.sin(angleStep), 0);
				//var v4 = new THREE.Vector3(segmentSphereRadius - segmentSphereRadius * Math.cos(angleStep), Math.sin(angleStep), segmentWidth);
				//var v5 = new THREE.Vector3(segmentSphereRadius - segmentSphereRadius * Math.cos(angleStep * 2), Math.sin(angleStep * 2), 0);
				//var v6 = new THREE.Vector3(segmentSphereRadius - segmentSphereRadius * Math.cos(angleStep * 2), Math.sin(angleStep * 2), segmentWidth);

				//geom.vertices.push(v1);
				//geom.vertices.push(v2);
				//geom.vertices.push(v3);
				//geom.vertices.push(v4);
				//geom.vertices.push(v5);
				//geom.vertices.push(v6);

				////逆时针顺序
				//geom.faces.push(new THREE.Face3(0, 3, 2));
				//geom.faces.push(new THREE.Face3(3, 0, 1));
				//geom.faces.push(new THREE.Face3(2, 5, 4));
				//geom.faces.push(new THREE.Face3(5, 2, 3));
				//geom.faces.push(new THREE.Face3(4, 7, 6));
				//geom.faces.push(new THREE.Face3(7, 4, 5));
				//geom.faces.push(new THREE.Face3(6, 9, 8));
				//geom.faces.push(new THREE.Face3(9, 6, 7));

				//创建顶点
				var vertexCount = quadrangleSegmentNumber * 2 + 2;

				for(var i = 0; i < vertexCount; i++) {

					var vertexPos = new THREE.Vector3(segmentSphereRadius - segmentSphereRadius * Math.cos(angleStep * Math.floor(i / 2)), segmentSphereRadius * Math.sin(angleStep * Math.floor(i / 2)) * yMultiply, isSinLine == false ? (i % 2) * segmentWidth : (i % 2) * segmentWidth + zMultiply * Math.sin((Math.PI * 2 / (vertexCount - 2)) * (i - (i % 2))));

					geom.vertices.push(vertexPos);
				}

				//逆时针顺序绘制三角形
				for(var i = 0; i < quadrangleSegmentNumber * 2; i++) {

					if((i % 2) == 0) {
						geom.faces.push(new THREE.Face3(i, i + 3, i + 2));
					} else {
						geom.faces.push(new THREE.Face3(i + 2, i - 1, i));
					}
				}

				var facesLength = geom.faces.length;
				var percentNumber = 1 / facesLength;
				var forCount = 1;

				for(var i = 0; i < facesLength; i++) {

					////tiled texture uv
					//if (i % 2 == 0) {
					//    geom.faceVertexUvs[0].push([
					//       new THREE.Vector2(0, 1),
					//       new THREE.Vector2(1, 0),
					//       new THREE.Vector2(1, 1)
					//    ])
					//} else {
					//    geom.faceVertexUvs[0].push([
					//       new THREE.Vector2(1, 0),
					//       new THREE.Vector2(0, 1),
					//       new THREE.Vector2(0, 0)
					//    ])
					//}

					//stretch one texture uv
					if(i % 2 == 0) {
						geom.faceVertexUvs[0].push([
							new THREE.Vector2((forCount - 1) * (2 * percentNumber), 1),
							new THREE.Vector2(forCount * (2 * percentNumber), 0),
							new THREE.Vector2(forCount * (2 * percentNumber), 1)
						])
					} else {
						geom.faceVertexUvs[0].push([
							new THREE.Vector2(forCount * (2 * percentNumber), 0),
							new THREE.Vector2((forCount - 1) * (2 * percentNumber), 1),
							new THREE.Vector2((forCount - 1) * (2 * percentNumber), 0),
						])

						forCount++;
					}
				}

				//更新geometry信息。
				geom.computeBoundingBox();
				geom.computeFaceNormals();
				geom.computeVertexNormals();
				geom.verticesNeedUpdate = true;
				geom.elementsNeedUpdate = true;
				//geom.morphTargetsNeedUpdate = true;
				geom.uvsNeedUpdate = true;
				geom.normalsNeedUpdate = true;
				geom.colorsNeedUpdate = true;
				geom.tangentsNeedUpdate = true;

				var textureName = "reath/models/";

				if(attackLevel == 0) {
					textureName += "movingLine.png";
				} else if(attackLevel == 1) {
					textureName += "movingLine1.png";
				} else if(attackLevel == 2) {
					textureName += "movingLine2.png";
				} else if(attackLevel == 3) {
					textureName += "movingLine3.png";
				} else {
					textureName += "movingLine.png";
				}

				var movingLineTexture = new THREE.ImageUtils.loadTexture(textureName);
				movingLineTexture.wrapS = movingLineTexture.wrapT = THREE.RepeatWrapping;
				//movingLineTexture.repeat.set(2, 2);

				//var movingLineMat = new THREE.MeshBasicMaterial({
				//    map: movingLineTexture, transparent: true, opacity: 1, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, alphaTest: 0.04
				//});

				var movingLineMat = new THREE.MeshBasicMaterial({
					map: movingLineTexture,
					side: THREE.DoubleSide,
					blending: THREE.AdditiveBlending,
					transparent: true,
					depthWrite: false
				});

				//var wireMaterial = new THREE.MeshBasicMaterial({
				//    color: 0xffffff,
				//    wireframe: true
				//})

				var cityLinePlaneObj = new THREE.Mesh(geom, movingLineMat);
				cityLinePlaneObjs.push(cityLinePlaneObj);
				cityLinePlaneObj.name = "cityLine_" + cityStartName + "_To_" + cityEndName;

				scene.add(cityLinePlaneObj);

				////三角形
				//var dataFlow = scene.getObjectByName("DataFlow");

				//var dataFlowNew1 = dataFlow.clone();
				//dataFlowNew1.name = "DataFlow_" + cityStartName + "_To_" + cityEndName;
				//dataFlowNew1.translateY(segmentSphereRadius * yMultiply + 0.1);
				//dataFlowNew1.translateZ(-segmentWidth);
				//dataFlowNew1.scale.set(0.4, 0.4, 0.4);
				//cityLinePlaneObj.add(dataFlowNew1);
				//allDataFlowObjs.push(dataFlowNew1);

				//var dataFlowNew2 = dataFlow.clone();
				//dataFlowNew2.name = "DataFlow_" + cityEndName + "_To_" + cityStartName;
				//dataFlowNew2.translateY(segmentSphereRadius * yMultiply + 0.1);
				//dataFlowNew2.translateZ(segmentWidth);
				//dataFlowNew2.rotateY(Math.PI);
				//dataFlowNew2.scale.set(0.4, 0.4, 0.4);
				//cityLinePlaneObj.add(dataFlowNew2);
				//allDataFlowObjs.push(dataFlowNew2);

				//把轴心调整到面片中部，模拟调整pivot效果
				cityLinePlaneObj.geometry.translate(-quadrangleSegmentNumber * segmentLength / 2, 0, -segmentWidth / 2);

				//设置cityLinePlaneObj位置和旋转。
				var cityMiddlePos = new THREE.Vector3((cityStart.position.x + cityEnd.position.x) / 2, (cityStart.position.y + cityEnd.position.y) / 2, (cityStart.position.z + cityEnd.position.z) / 2);
				cityLinePlaneObj.position.copy(cityMiddlePos);
				cityLinePlaneObj.lookAt(zeroVec3);
				cityLinePlaneObj.rotateX(-Math.PI / 2);

				var vectorTwoCity = new THREE.Vector3(cityEnd.position.x - cityStart.position.x, cityEnd.position.y - cityStart.position.y, cityEnd.position.z - cityStart.position.z);

				var firstVertex = cityLinePlaneObj.geometry.vertices[0].clone();
				var secondLastVertex = cityLinePlaneObj.geometry.vertices[cityLinePlaneObj.geometry.vertices.length - 2].clone();

				cityLinePlaneObj.updateMatrixWorld(); //更新模型的世界矩阵。

				firstVertex.applyMatrix4(cityLinePlaneObj.matrixWorld);
				secondLastVertex.applyMatrix4(cityLinePlaneObj.matrixWorld);

				var vectorSecondLastVertexToFirstVertex = new THREE.Vector3(secondLastVertex.x - firstVertex.x, secondLastVertex.y - firstVertex.y, secondLastVertex.z - firstVertex.z);
				var thetaBetweenCiytsAndLine = Math.acos(vectorSecondLastVertexToFirstVertex.dot(vectorTwoCity) / (vectorSecondLastVertexToFirstVertex.length() * vectorTwoCity.length()));

				//正是顺时针转、负是逆时针转
				if(cityEnd.position.y > cityMiddlePos.y) {
					cityLinePlaneObj.rotateY(-thetaBetweenCiytsAndLine);
					//console.log("大于: " + cityLinePlaneObj.name + " : " + (-thetaBetweenCiytsAndLine * 57.3));
				} else {
					cityLinePlaneObj.rotateY(thetaBetweenCiytsAndLine);
					//console.log("小于: " + cityLinePlaneObj.name + " : " + thetaBetweenCiytsAndLine * 57.3);
				}

				cityLinePlaneObj.translateY(0.9); //往外移一点

				var mapOffset = {
					offX: 0
				};
				var tweenMapOffsetX = new TWEEN.Tween(mapOffset)
					.to({
						offX: 1
					}, Math.random(0, 1) * 1000 + 500)
					.onUpdate(function() {
						cityLinePlaneObj.material.map.offset.x = -this.offX;
						//console.log(this.offX);
					})
					.repeat(Infinity)
					//.easing(TWEEN.Easing.Quadratic.In)
					.start();

				allTweens.push(tweenMapOffsetX);
			}

			function DestoryALLCityLinePlane() {
				if(cityLinePlaneObjs) {
					var obj;
					for(var i = 0; i < cityLinePlaneObjs.length; i++) {
						obj = cityLinePlaneObjs[i];

						scene.remove(obj);

						obj.geometry.dispose();
						obj.material.dispose();
					}
				}

				cityLinePlaneObjs = [];
			}

			var camDis;
			var disScale;

			function render() {

				requestAnimationFrame(render);

				//背光面片需要面向相机（需要放到renderer.render(scene, camera);前面，否则会有闪烁）
				if(backlightObj != null) {
					backlightObj.lookAt(camera.position);
					//backlightObj.quaternion.copy(camera.quaternion); 也可
				}

				//outGeo
				if(outGeo != null) {
					outGeo.lookAt(camera.position);
				}

				renderer.render(scene, camera);

				//controls.update();
				TWEEN.update();

				//FallOff渐变球一直朝向相机
				if(earthFallOff != null) {
					earthFallOff.material.uniforms.viewVector.value = new THREE.Vector3().subVectors(camera.position, earthFallOff.position);
				}

				//动态调整location、selector大小
				camDis = zeroVec3.distanceTo(camera.position);
				disScale = camDis / camMaxDistance + 0.1;

				for(var i = 0; i < cityLocationObjs.length; i++) {
					cityLocationObjs[i].scale.set(disScale, 1, disScale);
					citySelectorObjs[i].scale.set(disScale, 1, disScale);
					cityNameObjs[i].scale.set(disScale + 0.2, disScale + 0.2, disScale + 0.2);

					//citySelector.translateY(0.8);
				}

				//if (cityLinePlaneObjs) {
				//    for (var i = 0; i < cityLinePlaneObjs.length; i++) {
				//        cityLinePlaneObjs[i].material.map.offset.x -= 0.02;
				//    }
				//}
			}

			function enableMouseMoveFunc() {
				isMouseMoveFuncRun = true;
			}

			function disableMouseMoveFunc() {
				isMouseMoveFuncRun = false;
			}

			var raycaster = new THREE.Raycaster();
			var mousemoveNowTouchDataFlowName;
			var mousemovePreTouchDataFlowName;
			var dataflowUI;

			function onRayMouseMove() {

				if(isMouseMoveFuncRun == false) return;

				raycaster.setFromCamera(mousePos, camera);

				//var intersects = raycaster.intersectObjects(allDataFlowObjs, true);
				var intersects = raycaster.intersectObjects(allDataFlowObjs, false);

				if(intersects[0] != null) {

					mousemovePreTouchDataFlowName = mousemoveNowTouchDataFlowName;
					mousemoveNowTouchDataFlowName = intersects[0].object.name;

					if(mousemoveNowTouchDataFlowName != mousemovePreTouchDataFlowName) {
						console.log("打开面板：" + mousemoveNowTouchDataFlowName);
						//dataflowUI = createDataFlowUI("城市1", "城市2");
					}
				}

				if(intersects[0] == null) {
					console.log("关闭面板！");
					mousemoveNowTouchDataFlowName = "";
					//面板是否打开？若有关闭所有的面板 CloseDataFlowUI(dataflowUI);
				}
			}

			document.onkeydown = function(event) {

				var e = event || window.event || arguments.callee.caller.arguments[0];

				if(e && e.keyCode == 71) //g
				{
					//generateCubeColumn(cloudResourceTestArgs);
					//setSecurityIncidentsLevel("beijing", 1);
					//showSingleCity("beijing");
					//rotateToCity("beijing");

					//enableMouseMoveFunc();
				}

				if(e && e.keyCode == 68) //d
				{
					destoryAllCitys();
					creatCitys("辽源", "liaoyuan", 42.894, 125.150);
					creatCitys("北京", "beijing", 39.911, 116.4);
					creatCitys("烟台", "yantai", 37.469, 121.454);
					creatCitys("襄阳", "xiangyang", 32.014, 112.129);
					creatCitys("新县", "xinxian", 31.6497, 114.885);
					creatCitys("武汉", "wuhan", 30.598, 114.3118);
					creatCitys("无锡", "wuxi", 31.4967, 120.3189);
					creatCitys("昆山", "kunshan", 31.39, 120.988);
					creatCitys("眉山", "meishan", 30.081, 103.855);
					creatCitys("深圳", "shenzhen", 22.548, 114.066);
					creatCitys("旧金山", "SanFrancisco", 37.46, -122.26);
					creatCitys("旧金山", "SanFrancisco", 37.46, -122.26);
					creatCitys("旧金山", "SanFrancisco", 37.46, -122.26);
					creatCitys("旧金山", "SanFrancisco", 37.46, -122.26);
					creatCitys("旧金山", "SanFrancisco", 37.46, -122.26);
					creatCitys("海口", "haikou", 20, 110);

					createCityLinePlane("meishan", "SanFrancisco", 1);
					createCityLinePlane("kunshan", "SanFrancisco", 2);
					createCityLinePlane("shenzhen", "SanFrancisco", 3);
					createCityLinePlane("yantai", "SanFrancisco", 0);
					createCityLinePlane("liaoyuan", "SanFrancisco", 1);
					createCityLinePlane("SanFrancisco", "SanFrancisco", 2);

					//for (var i = 0; i < 5 * 5; i++) {
					//    for (var j = 0; j < 5 * 5; j++) {
					//        if (i != j) {
					//            createCityLinePlane("ceshi" + i, "ceshi" + j);
					//        }
					//    }
					//}
				}

				if(e && e.keyCode == 72) //h
				{
					//setSecurityIncidentsLevel("kunshan", 1);
					//showSingleCity("meishan");
					//showAllCity();

					//DestoryALLCityLinePlane();

					//disableMouseMoveFunc();
				}

				var stepTmp = 0.01;
				if(e && e.keyCode == 83) //s
				{
					//stopAllSecurityIncidents();

					//CreateCityLine("beijing", "kunshan");
					//CreateCityLine("beijing", "yantai");
					//CreateCityLine("beijing", "xinxian");
					//CreateCityLine("xinxian", "kunshan");
					//CreateCityLine("wuhan", "wuxi");
					//CreateCityLine("kunshan", "wuxi");
					//CreateCityLine("shenzhen", "wuxi");
					//CreateCityLine("cs1", "cs2");
					//CreateCityLine("cs3", "cs4");
				}
			}

			function destoryAllCitys() {
				for(var i = 0; i < cityLocationObjs.length; i++) {
					cityLocationObjs[i].material.dispose();
					cityLocationObjs[i].geometry.dispose();

					citySelectorObjs[i].material.dispose();
					citySelectorObjs[i].geometry.dispose();

					cityNameObjs[i].material.dispose();
					cityNameObjs[i].geometry.dispose();

					scene.remove(cityLocationObjs[i]);
					scene.remove(citySelectorObjs[i]);
					scene.remove(cityNameObjs[i]);
				}

				cityLocationObjs = [];
				citySelectorObjs = [];
				cityNameObjs = [];
				DestoryALLCityLinePlane();

			}
		</script>
		<script src="js/index.js" type="text/javascript" charset="utf-8"></script>
	</body>

</html>